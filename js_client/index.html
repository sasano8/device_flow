<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Device Code Form</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #mapid {
            height: 1000px;  /* 高さを設定 */
            width: 1000px;   /* 幅を設定（高さと同じにする） */
            margin: auto;   /* 中央寄せにするためのスタイル（オプション） */
        }
    </style>
</head>
<body>
    <h1>アプリケーションの目的</h1>
    設定からビルドまでの手順を簡単にし、モックアップを作成する。
    モックアップは、アプリケーションのモックアップはもちろんのこと、災害時に実用可能なアプリのビルドまでを対象とする。

    <form>
      <div>
        <label for="baseUrl">BackendBaseUrl:</label>
        <input type="text" id="baseUrl" name="baseUrl" required value="http://localhost:8000/">
      </div>

      <div>
        <label for="auth_mode">Auth Mode:</label>
        <select id="auth_mode" name="auth_mode">
          <option value="peacetime" seleced>peacetime</option>
          <option value="emergency">emergency</option>
        </select>
      </div>
    </form>

    <h1>緊急追跡アプリ用のトークン</h1>
    災害時などは、小難しい認証は不要で簡単に位置情報とデバイスを特定できるようにする。
    初期化時に、ローカルストレージにトークンが保存されていなければ、サーバーからトークンを取得し、ローカルストレージに保存する。
    <form>
      <label for="uniqueId">Unique ID:</label>
      <input type="text" id="uniqueId" name="uniqueId" required>
    </form>

    <h1>位置追跡アプリを起動し、clientId を発行します。</h1>
    clientId はデバイス、または、アプリケーションを識別するための文字列です。
    clientId を保護するには、セキュアストレージやマルチファクタ認証を検討します。

    <h1>clientId を指定し、デバイスコード・ユーザーコードを要求してください。</h1>
    デバイスコードは、デバイスを識別するための一時的な文字列で、認証が完了すると無効化されます。
    <form id="request_code_form">
        <label for="scope">Scope:</label>
        <input type="text" id="scope" name="scope" required value='read:user write:user'>

        <label for="clientId">Client ID:</label>
        <input type="text" id="clientId" name="clientId" required>

        <input type="submit" value="デバイスコード・ユーザーコードを要求する">
    </form>

    <h1>デバイスコード・ユーザーコードの要求結果が表示されます。ユーザーコードを提示し、デバイスを承認してください。</h1>
    <form id="connect_device_form">
      <label for="deviceCode">Device Code:</label>
      <input type="text" id="deviceCode" name="deviceCode" required>

      <label for="userCode">User Code:</label>
      <input type="text" id="userCode" name="userCode" required>
    </form>

    <h1>ユーザーコード提示後、デバイスが接続が承認され、アクセストークンが返されます。</h1>
    <form>
      <div>
        <label for="access_token">Access Token:</label>
        <input type="text" id="access_token" name="access_token" required>
      </div>
      <div>
        <label for="refresh_token">Refresh Token:</label>
        <input type="text" id="refresh_token" name="refresh_token" required>
      </div>
      <div>
        <label for="token_type">Token Type:</label>
        <input type="text" id="token_type" name="token_type" required>
      </div>
      <div>
        <label for="access_token_expires_in">Access Token Expires In:</label>
        <input type="text" id="access_token_expires_in" name="access_token_expires_in" required>
      </div>
    </form>

    <h1>アクセストークンを使用し位置情報の送受信を開始します。</h1>
    <form>
      <div>
        <label for="connect_checkbox">connect/disconnect:</label>
        <input type="checkbox" id="connect_checkbox" name="connect_checkbox" checked />
      </div>

      <div>
        <label for="timeline_mode">Timeline Mode:</label>
        <select id="timeline_mode" name="timeline_mode">
          <option value="realtime" seleced>realtime</option>
          <option value="realtime+history">realtime+history</option>
          <option value="history">history</option>
        </select>
      </div>

      <div>
        <label for="datasource_mode">Datasource Mode:</label>
        <select id="app_mode" name="app_mode">
          <option value="test_data" seleced>test_data</option>
          <option value="watchPosition">watchPosition</option>
          <option value="getCurrentPosition">getCurrentPosition</option>
          <option value="manualPostion">manualPostion</option><!-- GPSを使用できない場合は、位置情報を手動で入力する -->
        </select>
      </div>

      <div>
        <label for="connection_mode">ConnectionMode:</label>
        <select id="connection_mode" name="connection_mode">
          <option value="polling" seleced>polling</option>
          <option value="websocket">websocket</option>
        </select>
      </div>

      <div>
        <label for="log">log</label>
        <input type="text" id="log" name="log" required value="" style="width: 600px;">
      </div>
    </form>

  <div id="mapid"></div>
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<script>
// 参考: 特務機関NERV防災
layers = [
    "地理的特徴",
    "経路",
    "施設",
    "インフラ", // 橋など
    "行政区域",
    ""
];


topics = [
    "雨雲レーダー",
    "キキクル（危険度分布）",
    "河川",
    "台風",
    "アメダス",
    "雪",
    "天気分布予報",
    "強震モニタ",
    "鉄道",
    "渋滞",
    "事件",
    "お祭り",
    "リアルタイム"
];

class LocationSubject {
    constructor() {
        this.observers = [];
    }

    subscribe(observer) {
        this.observers.push(observer);
    }

    unsubscribe(observer) {
        this.observers = this.observers.filter(obs => obs !== observer);
    }

    notifyObservers(position) {
        this.observers.forEach(observer => observer.update(position));
    }
}

class LocationObserver {
    constructor(func) {
        this.func = func;
    }
    update(position) {
        const result = this.func(position);
        if (result instanceof Promise) {
            result.then((res) => {}).catch(err => {

            });
        }
    }
}

async function requestDeviceCode(baseUrl, clientId, scope) {
    const url = new URL("generate_device_user_codes?client_id=" + clientId, baseUrl.value);
    const response = await fetch(url.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            client_id: clientId,
            // Oauth2.0 の scope
            // スペースが区切り文字列
            // 大文字小文字は区別される
            // scope を省略した場合は、デフォルトのスコープが使用される（実装依存）
            // 実装例: https://docs.github.com/ja/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#available-scopes
            scope: 'read:user write:user'
        })
    });
    return await response.json();
}

async function pollForToken(baseUrl, clientId, deviceCode) {
    const grant_type = "urn:ietf:params:oauth:grant-type:device_code";
    const url = new URL("poll_for_access_token?grant_type=" + grant_type + "&device_code=" + deviceCode + "&client_id=" + clientId, baseUrl);
    const response = await fetch(url.href, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json'
        }
    });

    return await response.json();
}

async function updateLocation(baseUrl, access_token, lat, lng) {
    const grant_type = "urn:ietf:params:oauth:grant-type:device_code";
    const url = new URL("update_location?lat=" + lat + "&lng=" + lng, baseUrl);
    const response = await fetch(url.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + access_token
        }
    });

    return await response.json();
}


function generateUniqueId() {
    return 'id-' + Math.random().toString(36).substr(2, 16);
}

function setUniqueId(uniqueId = null) {
    let id = localStorage.getItem('uniqueId');
    if (!id) {
        id = generateUniqueId();
        localStorage.setItem('uniqueId', id);
    }

    if (uniqueId) {
        uniqueId.value = id;
    }
}

const appMode = document.getElementById('app_mode');
const deviceCodeForm = document.getElementById('request_code_form');
const connectCheckbox = document.getElementById('connect_checkbox');
const uniqueId = document.getElementById('uniqueId');

setUniqueId(uniqueId);


deviceCodeForm.addEventListener('submit', async function(event) {
    event.preventDefault(); // ページ再読みを防ぐ

    const baseUrl = document.getElementById('baseUrl');
    const clientId = document.getElementById('clientId').value;
    const scope = document.getElementById('scope').value;

    res = await requestDeviceCode(baseUrl, clientId, scope);

    document.getElementById('deviceCode').value = res.device_code;
    document.getElementById('userCode').value = res.user_code;

    // requestDeviceCode(deviceCode, userCode);
});



function sendMessage(msg) {
    const dt = new Date().toISOString();
    document.getElementById('log').value = dt + " " + msg;
}

document.addEventListener('DOMContentLoaded', async () => {
    getRunnging = () => {
        return connectCheckbox.checked;
    };

    await startLocationMonitoring(getRunnging, sendMessage);
});


async function startLocationMonitoring(getRunnning, sendMessage) {
    const baseUrl = document.getElementById('baseUrl');
    const clientId = document.getElementById('clientId');
    const deviceCode = document.getElementById('deviceCode');
    const access_token = document.getElementById('access_token');
    const refresh_token = document.getElementById('refresh_token');
    const token_type = document.getElementById('token_type');
    const access_token_expires_in = document.getElementById('access_token_expires_in');


    while (true) {
        // デバイスコードが有効になるまでポーリング
        let res_token = null;
        let watch_id = null;

        while (true) {
            // connect が要求されるまで待機
            if (!getRunnning()) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                continue;
            }

            // デバイスコードが有効になるまで待機
            try {
                res_token = await pollForToken(baseUrl.value, clientId.value, deviceCode.value);
            } catch (e) {
                sendMessage(e)
                continue;
            }

            if (res_token.access_token) {
                break;
            } else if (res_token.error === 'authorization_pending') {
                sendMessage("[INFO] wait for authorization...")
            } else {
                sendMessage("[INFO] wait for authorization...")
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        access_token.value = res_token.access_token;
        refresh_token.value = res_token.refresh_token;
        token_type.value = res_token.token_type;
        access_token_expires_in.value = res_token.access_token_expires_in;

        // 位置情報を送り続ける
        // デバイスの位置が変わった場合のみ送信したい場合は、watchPosition
        // 常に送信したい場合は、getCurrentPosition（ただし、常に位置情報へのアクセス許可が要求される）
        const mode = appMode.value;
        if (mode == "watchPosition") {
            watch_id = navigator.geolocation.watchPosition(
                async (position) => {
                        const {
                            latitude,
                            longitude
                        } = position.coords;
                        position.coords.altitude; // 全てのGPSで取得できるわけではない（nullが返る）
                        sendMessage(`Latitude: ${latitude}, Longitude: ${longitude}`);
                        subject.notifyObservers(position);
                        try {
                            const data = await updateLocation(baseUrl.value, res_token.access_token, latitude, longitude)
                        } catch (e) {
                            sendMessage(e.message)
                        }
                    },
                    function(e) {
                        sendMessage(e.message);
                    }, {
                        "enableHighAccuracy": true, // 高精度
                        "timeout": null, // タイムアウトなし
                        "maximumAge": Infinity // 常に最新の位置情報を返す
                    }
            );

            // disconnect が要求されるまで待機
            while (true) {
                if (getRunnning()) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    continue;
                } else {
                    break;
                }
            }

            navigator.geolocation.clearWatch(watch_id);

        } else if (mode == "getCurrentPosition") {
            while (true) {
                if (getRunnning()) {} else {
                    break;
                }

                navigator.geolocation.getCurrentPosition(
                    position => {
                        const {
                            latitude,
                            longitude
                        } = position.coords;
                        sendMessage(`Latitude: ${latitude}, Longitude: ${longitude}`);
                        subject.notifyObservers(position);
                    },
                    function(e) {
                        sendMessage(e.message);
                    }, {
                        "enableHighAccuracy": true, // 高精度
                        "timeout": 10000, // タイムアウトなし
                        "maximumAge": Infinity // 常に最新の位置情報を返す
                    }
                );

                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        } else if (mode == "test_data") {
            while (true) {
                const milliseconds = 1000;
                const positions = [
                    {
                        latitude: 36.554560344660054,
                        longitude: 139.95027239072502,
                    },
                    {
                        latitude: 36.554560344660054 + 0.001,
                        longitude: 139.95027239072502 + 0.001,
                    },
                    {
                        latitude: 36.554560344660054 + 0.002,
                        longitude: 139.95027239072502 + 0.002,
                    }
                ];

                for (const position of positions) {
                    subject.notifyObservers({
                        coords: position
                    });
                    await new Promise(resolve => setTimeout(resolve, milliseconds));
                }

            };
        } else {
            throw new Error("invalid mode");
        }

    }

}


var mapid = 'mapid';
// s: サブドメイン（不可分散に利用） z: ズームレベル x: タイルのx座標 y: タイルのy座標
var tileurl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
var maxZoom = 19;
var attribution = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';

var centerPoint = [36.554560344660054, 139.95027239072502]; // GeoJson と緯度・経度の順番が逆なことに注意
var zoomlevel = 13;

var myStyle = {
    "color": "blue",
    "weight": 10,
    "opacity": 0.65
};

var geojsonData = {
    "type": "FeatureCollection",
    "features": [{
            "type": "Feature",
            "properties": {
                "popupContent": "Train A",
                "amenity": "Baseball Stadium"
            },
            "geometry": {
                "type": "Point",
                "coordinates": [
                    139.95027239072502 + 0.01,
                    36.554560344660054 + 0.01,
                ]
            }
        },
        {
            "type": "Feature",
            "properties": {
                "popupContent": "Train B",
                "show_on_map": false
            },
            "geometry": {
                "type": "Point",
                "coordinates": [
                    139.95027239072502 - 0.01,
                    36.554560344660054 - 0.01,
                ]
            }
        },
        {
            "type": "Feature",
            "properties": {},
            "geometry": {
                "type": "LineString",
                "coordinates": [
                    [139.89844464439608, 36.55870018293028],
                    [139.94128861359127, 36.55672812989238],
                    [139.9616473441539, 36.56880018968707],
                    [139.97738050607467, 36.56557497820353],
                    [139.98350618492697, 36.56710964046614],
                    [139.98468636158583, 36.574466568416895],
                    [139.98401197492296, 36.58101048585654],
                    [139.9866533226854, 36.57943097035752],
                    [139.9883954882293, 36.57897967428006],
                    [139.9981740948362, 36.5784832455477],
                    [139.99929807260827, 36.57807707421047],
                    [140.00002865815787, 36.57726472512594],
                    [140.0014898292614, 36.57812220446485],
                    [140.00300719925173, 36.57992739299627],
                    [140.0070535192266, 36.581236128289575],
                    [140.00845849144122, 36.58444017966819],
                    [140.00930147476868, 36.58489144382568]
                ]
            }
        }
    ]
}


var mymap = L.map(mapid).setView(centerPoint, zoomlevel);

// OpenStreetMapを背景地図として設定
L.tileLayer(tileurl, {
    maxZoom,
    attribution
}).addTo(mymap);

// GeoJSONを地図に追加
L.geoJSON(geojsonData, {
    style: myStyle,
    onEachFeature: function(feature, layer) {
        if (feature.properties && feature.properties.popupContent) {
            layer.bindPopup(feature.properties.popupContent);
        }
    },
    filter: function(feature, layer) {
        return feature.properties.show_on_map ?? true;
    }
}).addTo(mymap);

const me_marker = L.marker([0, 0]).addTo(mymap);


class MapManager {
    constructor(map) {
        this.map = map;
        this.me = null;
        this.markers = [];
    }

    add_me(point) {
        if (this.me) {
            throw new Error("me already exists");
        }
        const {
            latitude,
            longitude
        } = point;
        const marker = L.marker([latitude, longitude]).addTo(this.map);
        this.me = marker;
        this.me.setLatLng([latitude, longitude]);
    }

    show_me(show) {
        if (this.me) {
            if (show) {
                this.me.addTo(this.map); // 何度呼び出しても大丈夫
            } else {
                this.map.removeLayer(this.me);
            }
        }
    }

    update_me(point) {
        const {
            latitude,
            longitude
        } = point;
        this.me.setLatLng([latitude, longitude]);
    }
}

var mm = new MapManager(mymap);
var me = mm.add_me({
    latitude: 0,
    longitude: 0
});

subject = new LocationSubject();
observer_me = new LocationObserver((position) => {
    mm.update_me(position.coords);
});
subject.subscribe(observer_me);

function detect_abnormal_position() {
    // 短期間での移動距離が大きい場合は、異常とみなす
}

</script>
</body>
</html>

